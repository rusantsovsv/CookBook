"""
У вас есть много словарей или отображений, которые вы хотите логически объ-
единить в одно отображение, чтобы выполнить некоторые операции, такие как
поиск значений или проверка существования ключей.

Предположим, что вы хотите провести поиски, в ходе которых вам
нужно проверить оба словаря (то есть сначала проверить в словаре a, а потом в b,
если в первом словаре искомое не найдено). Простой способ сделать это – исполь-
зовать класс ChainMap из модуля collections.
"""
from collections import ChainMap

a = {'x': 1, 'z': 3}
b = {'y': 2, 'z': 4}

c = ChainMap(a, b)
print(c['x'])           # Выводит 1 (из a)
print(c['y'])           # Выводит 2 (из b)
print(c['z'])           # Выводит 3 (из a)

"""
ChainMap принимает несколько отображений и делает их логически единым
целым. Однако в буквальном смысле они не сливаются. Вместо этого ChainMap
просто содержит список отображений и переопределяет обычные операции над
словарями для сканирования данного списка. Большинство операций работает.
Например:
"""
print(len(c))
print(list(c.keys()))
print(list(c.values()))

"""
В случае появления одинаковых ключей будут использованы значения из пер-
вого словаря. Например, c['z'] в примере всегда будет ссылаться на значение из
словаря a, а не из b.
Операции, которые изменяют отображение, всегда действуют на первое отображение
в списке. Например:
"""
c['z'] = 40
c['w'] = 10
del c['x']

print(c)

# del c['y'] - KeyError: "Key not found in the first mapping: 'y'"

"""
ChainMap особенно полезны для работы со значениями, принадлежащими об-
ластям видимости, такими как переменные языка программирования (глобаль-
ные, локальные и т. п.). На самом деле даже существуют методы, которые все упро-
щают:
"""

values = ChainMap()
values['x'] = 1
# добавляем новое отображение
values = values.new_child()
values['x'] = 2
# добавляем новое отображение
values = values.new_child()
values['x'] = 3
print(values)

# Удаляем последнее отображение
values = values.parents
values['x']
print(values)

# Удаляем последнее отображение
values = values.parents
values['x']
print(values)

"""
В качестве альтернативы ChainMap вы можете обдумать слияние словарей с ис-
пользованием метода update(). Например:
"""
a = {'x': 1, 'z': 3}
b = {'y': 2, 'z': 4}

merged = dict(b)
merged.update(a)
print(merged)

"""
Это работает, но требует от вас создания полностью нового объекта словаря
(или необратимого изменения одного из существующих). В этом случае при из-
менении одного из первоначальных словарей изменения не затронут новый объ-
ект объединенного словаря. Например:
"""
print(a['x'])
print(merged['x'])

a['x'] = 99

print(a['x'])
print(merged['x'])

"""
ChainMap использует первоначальные словари, поэтому не подвержен такому
поведению.
"""

a = {'x': 1, 'z': 3}
b = {'y': 2, 'z': 4}
merged = ChainMap(a, b)
print(merged['x'])
a['x'] = 42
print(merged['x'])          # Изменение происходит и в объединенных словарях
