"""
Вам нужно инкапсулировать «приватные» данные в экземпляре класса, но вас
беспокоит, что в Python нет контроля доступа.

Вместо того чтобы полагаться на возможности языка по инкапсулированию
данных, от программистов на Python ожидается соблюдение определенных со-
глашений о наименовании, касающихся намеренного использования данных
и методов. Первое соглашение состоит в том, что любое имя, которое начинает-
ся с одного нижнего подчеркивания (_), должно рассматриваться как внутренняя
реализация.
Например:
"""

class A:
    def __init__(self):
        self._internal = 0      # внутренний атрибут
        self.public = 1         # внешний атрибут

    def public_method(self):
        """
        внешний метод
        """
        pass

    def _internal_method(self):
        """
        внутренний метод
        """
        pass

"""
Python не запрещает доступ к внутренним именам. Однако это считается не-
правильным, и в результате может получиться хрупкий код. Также стоит отметить, 
что имена, начинающиеся с нижнего подчеркивания, еще используются для
модулей и функций уровня модуля. Например, если вы видите имя модуля, кото-
рое начинается с нижнего подчеркивания (например, _socket), то это внутренняя
реализация. Аналогично функции уровня модуля, такие как sys._getframe(), долж-
ны применяться очень осторожно.
Вы можете натолкнуться на имена внутри классов, которые начинаются с двух
нижних подчеркиваний (__). Например:
"""

class B:
    def __init__(self):
        self.__private = 0

    def __private_method(self):
        pass

    def public_method(self):
        pass

"""
Использование двойного нижнего подчеркивания вызывает искажение имени
в другое. Если говорить конкретно, то приватные атрибуты в представленном выше
классе переименуются в _B__private и _B__private_method соответственно. Здесь вы
можете спросить, зачем нужны такие искажения. Причина – наследование: такие
атрибуты не могут быть переопределены через наследование. Например:
"""
class C(B):
    def __init__(self):
        super().__init__()
        self.__private = 1          # не перегружает B.__private

    # не перегружает B.__private_method()
    def __private_method(self):
        pass

"""
Здесь приватные имена __private и __private_method переименуются в _C__private
и _C__private_method, которые отличаются от искаженных имен в базовом классе B.
"""

