"""
Вы хотите написать генератор, но функция работает с дополнительным состояни-
ем, которое вам хотелось бы каким-то образом показать пользователю.

Если вам нужен генератор, который показывает пользователю дополнительное
состояние, не забудьте, что вы можете легко реализовать его в форме класса, по-
местив код генератора в метод __iter__(). Например:
"""

from collections import deque


class LineHistory:

    def __init__(self, lines, histlen=3):
        self.lines = lines
        self.history = deque(maxlen=histlen)

    def __iter__(self):
        for lineno, line in enumerate(self.lines, 1):
            self.history.append((lineno, line))
            yield line

    def clear(self):
        self.history.clear()

"""
Вы можете обращаться с этим классом так же, как с обычным генератором. Од-
нако, поскольку он создает экземпляр, вы можете обращаться к внутренним атри-
бутам, таким как history или метод clear(). Например:
"""

with open('passw.txt') as f:
    lines = LineHistory(f)
    for line in lines:
        if 'python' in line:
            for lineno, hline in lines.history:
                print('{}:{}'.format(lineno, hline), end='')

"""
С генераторами легко попасть в ловушку, если пытаться делать все только с по-
мощью функций. В результате может получиться сложный код, если генератору
нужно взаимодействовать с другими частями программы некими необычными
способами (раскрытие атрибутов, разрешение на управление через вызов мето-
дов и т. п.). В этом случае просто используйте определение класса, как показано
выше. Определение генератора в методе __iter__() не изменит ничего в том, как вы
напишете алгоритм. Но тот факт, что генератор станет частью класса, упростит
задачу предоставления пользователям атрибутов и методов для каких-то взаи-
модействий.
"""
