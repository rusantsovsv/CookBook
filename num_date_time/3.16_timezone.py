"""
У вас назначена телефонная конференция на 21 декабря 2012 года в 9:30 утра
в Чикаго. В какое местное время ваш друг из индийского города Бангалор должен
выйти на связь?

Для практически любых задач, связанных с временными зонами, вы можете ис-
пользовать модуль pytz. Этот пакет предоставляет базу временных зон Олсона (tz
databaze), которая является стандартом де-факто для многих языков программи-
рования и операционных систем.
Большая часть случаев использования pytz приходится на приведение к локаль-
ному времени дат, созданных с помощью библиотеки datetime. Например, вот как
вы могли бы представить дату с чикагским местным временем:
"""

from datetime import datetime, timedelta
from pytz import timezone, utc

d = datetime(2012, 12, 21, 9, 30, 0)
print(d)

# Локализуем дату для Чикаго

central = timezone('US/Central')
loc_d = central.localize(d)
print(loc_d)

"""
Когда дата локализована, ее можно конвертировать в другие временные зоны.
Чтобы найти бангалорское время, вы можете сделать так:
"""

bang_d = loc_d.astimezone(timezone('Asia/Kolkata'))
print(bang_d)

"""
Если вы собираетесь выполнять арифметические операции над локализован-
ными датами, вам нужно знать о переводах времени с летнего на зимнее и прочих
подобных деталях. Например, в 2013 году стандартное летнее время США нача-
лось 13 марта в 2:00 ночи по местному времени городов (время было переведено
на час вперед). Если бы провели стандартную арифметическую операцию над да-
тами, то получили бы неверный результат. Например:
"""

d = datetime(2013, 3, 10, 1, 45)
loc_d = central.localize(d)

print(loc_d)

later = loc_d + timedelta(minutes=30)
print(later)        # не верно

"""
Ответ получается неверным, поскольку он не учитывает перевод местного
времени на один час. Чтобы исправить это, используйте метод временных зон
normalize(). Например:
"""

later = central.normalize(loc_d + timedelta(minutes=30))
print(later)

"""
Чтобы предотвратить взрыв головы, используйте обычную стратегию работы
с локальным временем: преобразование всех дат в UTC и использование уже их
для хранения и обработки. Например:
"""

print(loc_d)
utc_d = loc_d.astimezone(utc)
print(utc_d)

"""
Если время уже в UTC, вы можете не волноваться по поводу проблем, связан-
ных с переходом на летнее время, а также прочих подобных вещах. Вы свободно
можете выполнять арифметические операции с датами. Если же вы хотите вы-
вести дату в локальном времени, просто сконвертируйте в нужную временную
зону. Например:
"""

later_utc = utc_d + timedelta(minutes=30)
print(later_utc.astimezone(central))

"""
С использованием временных зон есть одна проблема: какие имена времен-
ных зон использовать? Например, в этом рецепте мы как-то узнали, что «Asia/
Kolkata» – это правильное название временной зоны для Индии. Чтобы узнать
название нужной зоны, поищите в словаре pytz.country_timezones, указывая в ка-
честве ключа код страны по ISO 3166. Например:
>>> pytz.country_timezones['IN']
['Asia/Kolkata']
>>>
К тому времени, как вы это прочтете, модуль pytz может быть признан устарев-
шим, а ему на смену придет улучшенная поддержка временных зон по PEP 4311.
Однако многие из описанных проблем все равно нужно будет учитывать (вопросы
работы с UTC и т. п.).
"""