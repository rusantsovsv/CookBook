"""
Ваша программа превратилась в нечитабельную массу индексов срезов, и вы хо-
тите все это расчистить.
"""

record = '....................100.......513.25..........'
cost = int(record[20:22]) * float(record[30:35])
print(cost)

# вместо этой записи можно присвоить имена срезам
SHARES = slice(20, 22)
PRICE = slice(30, 35)

cost = int(record[SHARES]) * float(record[PRICE])
print(cost)

# В последнем примере вы избежали появления кучи загадочных индексов, и код стал проще и яснее.

"""
Общее правило таково: написание кода с большим количеством неоформленных
индексов ведет к проблемам с читабельностью и поддерживаемостью. Например,
если вы вернетесь к такому коду через год, то наверняка не сразу вспомните, как
и о чем вы думали, когда все это писали. Приведенное выше решение – простой
путь к более ясному обозначению того, что делает ваш код.
Встроенная функция slice() создает объект среза, который может быть исполь-
зован везде, где применяются обычные срезы.
"""

items = [0, 1, 2, 3, 4, 5, 6]
a = slice(2, 4)
print(items[2:4])
print(items[a])
items[a] = [10, 11]
print(items)
del items[a]
print(items)

"""
Если у вас есть экземпляр slice, сохраненный в переменной s, вы можете по-
лучить больше информации о нем, если посмотрите на атрибуты s.start, s.stop
и s.step.
"""

a = slice(5, 50, 2)
print(a.start, a.stop, a.step)

"""
Также вы можете наложить срез на последовательность определенного
размера, используя его метод indices(size). Он возвращает кортеж (start, stop,
step), где все значения соответственно ограничены, чтобы вписаться в грани-
цы (дабы избежать возбуждения исключений IndexError при индексировании).
"""
s = 'HelloWorld'
print(a.indices(len(s)))
for i in range(*a.indices(len(s))):
    print(s[i])
