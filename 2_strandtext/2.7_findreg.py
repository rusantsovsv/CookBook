"""
Вы пытаетесь найти совпадение по текстовому шаблону, используя регулярное
выражение, но оно находит самое длинное из всех возможных совпадений. Вы же
хотите найти самое короткое из всех возможных.

Эта проблема часто возникает при использовании шаблонов, которые пытают-
ся найти текст, заключенный в пару открывающих и закрывающих разделителей
(например, строку в кавычках).
"""
import re

str_pat = re.compile(r'\"(.*)\"')
text1 = 'Computer says "no."'

print(str_pat.findall(text1))
text2 = 'Computer says "no." Phone says "yes."'

print(str_pat.findall(text2))

"""
В этом примере шаблон r'\»(.*)\»' пытается найти текст, заключенный в кавыч-
ки. Однако оператор * в регулярном выражении является жадным, поэтому поиск
получается поиском самого длинного из возможных совпадений. Поэтому во вто-
ром примере с переменной text2 неверно выполняется сопоставление двух строк
в кавычках.

Чтобы исправить это, добавьте модификатор ? после оператора * в шаблоне:
"""

str_pat = re.compile(r'\"(.*?)\"')
print(str_pat.findall(text2))

"""
Этот рецепт решает одну из часто встречающихся при написании регулярных вы-
ражений с символом точки (.) задач. В шаблоне точка соответствует любому сим-
волу, за исключением символа новой строки. Однако если вы окружите точку от-
крывающим и закрывающим текстом (таким как кавычки), поиск будет пытаться
найти самое длинное из возможных совпадений. Это вызывает многочисленные
случаи пропуска открывающего и закрывающего текста и включения в результа-
ты самого длинного совпадения. Добавление ? сразу после таких операторов, как
* или +, заставляет алгоритм поиска искать самое короткое совпадение.
"""

