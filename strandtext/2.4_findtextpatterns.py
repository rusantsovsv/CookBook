"""
Вы хотите отыскать совпадение или провести поиск по определенному шаблону.

Если текст, который вы хотите найти, является простым литералом, в большин-
стве случаев вам подойдут базовые строковые методы, такие как str.find(), str.
endswith(), str.startwith() и другие подобные.
"""

text = 'yeah, but no, but yeah, but no, but yeah'

# Точное совпадение
print(text == 'yeah')

# Совпадение по началу или концу
print(text.startswith('yeah'))
print(text.endswith('no'))

# Поиск места первого вхождения
print(text.find('no'))

"""
Для более сложного поиска совпадений используйте регулярные выражения
и модуль re. Чтобы проиллюстрировать базовые механики использования регу-
лярных выражений, предположим, что вы хотите найти даты, определенные циф-
рами, такие как «11/27/2012». Вот пример того, как вы можете это сделать:
"""
text1 = '11/27/2012'
text2 = 'Nov 27, 2012'

import re
# простое сопоставление: \d+ означает совпадение одной или более цифр
if re.match(r'\d+/\d+/\d+', text1):
    print('yes')
else:
    print('no')

if re.match(r'\d+/\d+/\d+', text2):
    print('yes')
else:
    print('no')

"""
Если вы собираетесь много раз искать по одному и тому же шаблону, часто оку-
пается предварительная компиляция шаблона регулярного выражения в объект
шаблона.
"""

datepat = re.compile(r'\d+/\d+/\d+')
if datepat.match(text1):
    print('yes')
else:
    print('no')

if datepat.match(text2):
    print('yes')
else:
    print('no')

"""
match() всегда пытается найти совпадения в начале строки. Если вы хотите про-
вести поиск по всем случаям соответствия шаблону, используйте метод findall().
"""

text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
print(datepat.findall(text))

"""
При составлении регулярных выражений часто нужно использовать захватыва-
ющие группы, заключая части шаблона в скобки. Например:
"""
datepat = re.compile(r'(\d+)/(\d+)/(\d+)')

"""
Захватывающие группы нередко упрощают последующую обработку найден-
ного текста, поскольку содержимое каждой группы может быть извлечено отдель-
но. Например:
"""

m = datepat.match('11/27/2012')

# извлекаем содержимое каждой группы
print(m.group(0))
print(m.group(1))
print(m.group(2))
print(m.group(3))
print(m.groups())

month, day, year = m.groups()

# Найти все совпадения
print(text)

print(datepat.findall(text))
for month, day, year in datepat.findall(text):
    print('{}-{}-{}'.format(year, month, day))

"""
Метод findall() проходит по тексту и находит все совпадения, возвращая их
в списке.
Если вы хотите искать совпадения итеративно, используйте метод
finditer():
"""

for m in datepat.finditer(text):
    print(m.groups())

"""
Вводного курса в теорию регулярных выражений в этой книге вы не найдете. Од-
нако этот рецепт демонстрирует простейшие примеры использования модуля
re для поиска совпадений в тексте. Самые основные приемы – компилирование
шаблонов
с использованием re.compile() и последующее использование таких ме-
тодов, как match(), findall() или finditer().
При составлении шаблонов часто нужно использовать «сырые» (raw) строки, та-
кие как r'(+)/(+)/(+)'. Подобные строки оставляют символы обратных слешей необ-
работанными, что может быть полезно в контексте применения регулярных вы-
ражений. С другой стороны, вы можете использовать двойные обратные слеши:
'(\\d+)/(\\d+)/(\\d+)'.
Учтите, что метод match() проверяет только начало строки. Возможно, что он
найдет вещи, которых вы не ожидаете. Например:
"""

m = datepat.match('11/27/2012abcdef')
print(m)

print(m.group())

"""
Если вам нужно точное совпадение, убедитесь, что шаблон включает символ
завершения ($), как в примере ниже:
"""

datepat = re.compile(r'(\d+)/(\d+)/(\d+)\$')
print(datepat.match('11/27/2012abcdef'))
print(datepat.match('11/27/2012'))

"""И последнее: если вы проводите простые операции поиска, вы часто можете
пропустить шаг компиляции и использовать функции уровня модуля из модуля
re. Например:"""

print(re.findall(r'(\d+)/(\d+)/(\d+)', text))

"""
Обратите внимание, что если вы проводите много операций поиска совпаде-
ний, часто окупается компилирование шаблона и многократное его использо-
вание. Функции уровня модуля поддерживают кеш недавно скомпилированных
шаблонов,
так что вы не получите огромного выигрыша в производительности,
но сэкономите несколько обращений и избежите лишней обработки, используя
ваш собственный скомпилированный шаблон.
"""