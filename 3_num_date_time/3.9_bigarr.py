"""
Вам нужно произвести вычисления на больших объемах числовых данных, таких
как массивы или решетки.

Для любых объемных вычислений с использованием массивов используйте библиотеку
NumPy. Ее главное преимущество в том, что она предоставляет объект
массива Python, который намного эффективнее и лучше подходит для математи-
ческих вычислений, нежели стандартный список Python. Вот короткий пример,
иллюстрирующий важные различия между обычными списками и массивами
NumPy:
"""
import numpy as np

# Списки Python
x = [1, 2, 3, 4]
y = [5, 6, 7, 8]
print(x * 2)

# print(x + 10)                 #TypeError: can only concatenate list (not "int") to list
print(x + y)

# массивы NumPy
ax = np.array([1, 2, 3, 4])
ay = np.array([5, 6, 7, 8])
print(ax * 2)
print(ax + 10)
print(ax + ay)
print(ax * ay)

"""
Как вы можете видеть, базовые математические операции с использованием
массивов выполняются по-разному. Конкретно скалярные операции (например,
ax * 2 или ax + 10) применяют операцию элемент за элементом. Также отметим,
что выполнение таких математических операций, где каждый из операндов
является массивом, применяет операцию ко всем элементам и создает новый
массив.
Тот факт, что математические операции применяются одновременно ко всем
элементам, позволяет очень просто и быстро применить функции ко всему мас-
сиву. Например, если вы хотите вычислить значение многочлена:
"""


def f(x):
    return 3*x**2 - 2*x + 7


print(f(ay))

"""
NumPy предоставляет набор «универсальных функций», которые также работают
для операций над массивами. Они подменяют похожие функции, доступные в мо-
дуле math. Например:
"""

print(np.sqrt(ax))
print(np.cos(ax))

"""
Использование универсальных функций позволяет выполнить вычисление
в сотни раз быстрее, чем проход по массиву и применение функций из math к каж-
дому элементу. Так что используйте их при любой возможности.
«Под капотом» массивы NumPy устроены похожим на массивы C или Fortran
образом. А именно они представляют собой большие смежные области памяти,
состоящие из однородных типов данных. Это дает возможность делать массивы
намного более крупными, чем позволяет обычный список Python. Например, если
вы хотите создать двумерную решетку размером 10 000×10 000 чисел с плаваю-
щей точкой, это не проблема:
"""

grid = np.zeros(shape=(10000, 10000), dtype=float)
print(grid)

"""
Все обычные операции все еще применяются к элементам одновременно:
"""
# grid += 10
# print(grid)
# print(np.sin(grid))

"""
Важнейший момент в использовании NumPy – это способ, которым она рас-
ширяет функциональность индексирования списков Python (особенно для много-
мерных массивов). Чтобы проиллюстрировать это, создадим простой двумерный
массив и поэкспериментируем:
"""

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
print(a)

# Выбираем строку 1
print(a[1])

# выбираем колонку 1
print(a[:, 1])

# выбираем и изменяем суб регион
print(a[1:3, 1:3])
a[1:3, 1:3] += 10
print(a)

# Транслируем строковый вектор на операции со всеми строками
print(a + [100, 101, 102, 103])

# условное присваивание в массиве
print(a)
print(np.where(a > 10, a, 5))

"""
NumPy – это основа огромного количества научных и инженерных библиотек
для Python. Из широко используемых модулей он является одним из крупнейших
и сложных. При этом можно делать полезные вещи с помощью NumPy, начав экс-
периментировать с простыми примерами.
Стоит отметить, что часто используется конструкция import numpy as np, как
и показано в нашем примере. Это сокращает название, чтобы было удобно вво-
дить его снова и снова в вашей программе.
Прочую информацию вы найдете на http://www.numpy.org.
"""