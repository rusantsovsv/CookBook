"""
У вас есть строка байтов, и вам нужно распаковать ее в целочисленное значение.
Или же вам нужно конвертировать большое целое число в байтовую строку.
Предположим, ваша программа должна работать с байтовой строкой из 16 эле-
ментов, которая содержит 128-битное целочисленное значение. Например:
"""

data = b'\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004'

"""
Чтобы перевести байты в целое число, используйте int.from_bytes(), определив
порядок следования байтов таким образом:
"""

print(len(data))

print(int.from_bytes(data, 'little'))
print(int.from_bytes(data, 'big'))

"""
Чтобы преобразовать большое целочисленное значение обратно в байтовую
строку, используйте метод int.to_bytes(), определив количество байтов и порядок
их следования. Например:
"""
x = 94522842520747284487117727783387188
print(x.to_bytes(16, 'big'))

print(x.to_bytes(16, 'little'))

"""
Преобразование больших целочисленных значений из и в байтовые строки – не
самая обычная операция. Однако иногда такая задача возникает в областях типа
криптографии или работы с сетью. Например, сетевые адреса IPv6 представлены
128-битными целыми числами. Если вы пишете программу, в которой нужно вы-
тягивать такие значения из данных, то можете столкнуться с этой задачей.
В качестве альтернативы вы можете попытаться распаковывать значения, ис-
пользуя модуль struct, как описано в рецепте 6.11. Это работает, но размер целых
чисел, которые могут быть распакованы с помощью struct, ограничен. 
Поэтому вам понадобится распаковывать несколько значений и объединять их для созда-
ния итогового значения. Например:
"""

print(data)
import struct
hi, lo = struct.unpack('>QQ', data)
print((hi << 64) + lo)

"""
Определение порядка следования байтов (little или big) просто указывает,
записаны
ли байты, из которых составляется целое число, в порядке от старшего
к младшему или наоборот. Это легко понять, рассмотрев пример такого специально
составленного шестнадцатеричного значения:
"""

x = 0x01020304
print(x.to_bytes(4, 'big'))
print(x.to_bytes(4, 'little'))

"""
Если вы хотите упаковать целое число в строку байтов, но оно не поместится,
вы получите ошибку. При необходимости вы можете использовать метод int.bit_
length(), чтобы определить, сколько байтов потребуется для хранения значения:
"""

x = 523 ** 23
print(x)
# x.to_bytes(16, 'little')                  # OverflowError: int too big to convert
print(x.bit_length())
nbytes, rem = divmod(x.bit_length(), 8)
if rem:
    nbytes += 1
print(x.to_bytes(nbytes, 'little'))
