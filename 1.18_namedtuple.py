# coding=utf-8
"""
У вас есть код, который осуществляет доступ к элементам в списке или кортеже по
позиции. Однако такой подход часто делает программу нечитабельной. Также вы
можете захотеть уменьшить зависимость от позиции в структуре данных путем
перехода к принципу доступа к элементам по имени.

collections.namedtuple() предоставляет такую возможность, добавляя лишь мини-
мальные затраты по сравнению с использованием обычного кортежа. collections.
namedtuple() – это фабричный метод, который возвращает подкласс стандартного
типа Python tuple (кортеж). Вы скармливаете этому методу имя типа и поля, кото-
рые он должен иметь. Он возвращает класс, который может порождать экземпляры с полями, вами определенными,
а также значениями этих полей, которые вы передадите при создании. Например:
"""

from collections import namedtuple
Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
sub = Subscriber('jonesy@example.com', '2012-10-19')

print(sub, sub.addr, sub.joined, sep='\n\n')

"""
Хотя экземпляр namedtuple (именованного кортежа) выглядит так же, как
и обычный экземпляр класса, он взаимозаменяем с кортежем и поддерживает все
обычные операции кортежей, такие как индексирование и распаковка.
"""

print(len(sub))

addr, joined = sub

print(addr, joined, sep='\n')

"""
Самый частый случай использования именованного кортежа – отвязка вашего
кода от работы с позициями элементов, которыми он манипулирует. Скажем, если
вы получаете большой список кортежей в ответ на запрос к базе данных, а потом
манипулируете ими через позиционное обращение к элементам, ваш код может
сломаться, если вы, например, добавите новую колонку в таблицу. Этого можно из-
бежать, если вы сначала превратите полученные кортежи в именованные кортежи.
Чтобы проиллюстрировать это, приведем пример кода, использующего обыч-
ные кортежи:
"""


def compute_cost(records):
    total = 0.0
    for rec in records:
        total += rec[1] + rec[2]
    return total

"""
Использование позиционного обращения к элементам часто делает код немно-
го менее выразительным и более зависимым от структуры записей. А вот версия
с использованием именованного кортежа:
"""

Stock = namedtuple('Stock', ['name', 'shares', 'price'])


def compute_cost2(records):
    total = 0.0
    for rec in records:
        s = Stock(*rec)
        total += s.shares * s.price
    return total


"""
Естественно, вы можете избежать явной конвертации в именованный кортеж
Stock, если последовательность records из примера уже содержит такие экземпляры.
"""

"""
Возможное использование именованного кортежа – замена словаря, который тре-
бует больше места для хранения. Так что если создаете крупные структуры дан-
ных с использованием словарей, применение именованных кортежей будет бо-
лее эффективным. Однако не забудьте, что именованные кортежи неизменяемы
(в отличие от словарей).
"""

s = Stock('ACME', 100, 123.45)
print(s.shares)

# s.shares = 75 - AttributeError: can't set attribute

"""
Если вам нужно изменить любой из атрибутов, это может быть сделано с по-
мощью метода _replace(), которым обладают экземпляры именованных кортежей.
Он создает полностью новый именованный кортеж, в котором указанные значе-
ния заменены.
"""

s = s._replace(shares=75)
print(s)

"""
Тонкость использования метода _replace() заключается в том, что он может стать
удобным способом наполнить значениями именованный кортеж, у которого есть
опциональные или отсутствующие поля. Чтобы сделать это, создайте прототип
кортежа, содержащий значения по умолчанию, а затем применяйте _replace() для
создания новых экземпляров с замененными значениями.
"""

Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])

# создание экземпляра прототипа
stock_prototype = Stock('', 0, 0.0, None, None)

# функция преобразования словаря в Stock
def dict_to_stock(s):
    return stock_prototype._replace(**s)


a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
print(dict_to_stock(a))

b = {'name': 'ACME', 'shares': 100, 'price': 123.45, 'date': '12/17/2012'}
print(dict_to_stock(b))

"""
Последнее, но важное замечание: стоит отметить, что если вашей целью яв-
ляется создание эффективной структуры данных, которая позволяет менять раз-
личные атрибуты экземпляров, использование именованных кортежей – не луч-
ший вариант. Вместо них стоит определить класс с использованием __slots__
"""
